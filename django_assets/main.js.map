{"version":3,"sources":["webpack://trick-track/./source/sass/style.sass?0047","webpack://trick-track/./source/js/add.js","webpack://trick-track/./source/js/bpm.js","webpack://trick-track/./source/js/cell.js","webpack://trick-track/./source/js/controls.js","webpack://trick-track/./source/js/matrix.js","webpack://trick-track/./source/js/playback-cells.js","webpack://trick-track/./source/js/player.js","webpack://trick-track/./source/js/project.js","webpack://trick-track/./source/js/slider.js","webpack://trick-track/./source/js/util.js","webpack://trick-track/webpack/bootstrap","webpack://trick-track/webpack/runtime/define property getters","webpack://trick-track/webpack/runtime/hasOwnProperty shorthand","webpack://trick-track/webpack/runtime/make namespace object","webpack://trick-track/./source/js/index.js"],"names":[],"mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;ACA+C;;AAE/C;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0DAAkB;AACzC;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5BA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,e;AACA;;AAE8C;;;;;;;;;;;;;;;;;;;ACnB9C;AACA;;AAEA,mBAAmB,WAAW;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC,yCAAyC;AACzC;AACA;AACA,iBAAiB;AACjB;AACA,GAAG;AACH;AACA;;AAEA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7DA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gC;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8B;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClC6C;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;;AAGA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;;AAEA;AACA,6B;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,yD;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,4DAAkB;AAC7D;;AAEA,KAAK;AACL,GAAG;AACH;;;AAGA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;;;;;AAMA,E;;;;;;;;;;;;;;;ACpIA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;;;AAG1B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,S;AACA;AACA;AACA;;AAEA,KAAK;AACL;;;;;;;;;;;;;;;;;AC9BA;AACA;;AAEA;AACA,UAAU,SAAS;AACnB,mB;AACA;;AAEA;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACxBA;AACA,qBAAqB;AACrB;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;;;AC1CxC;;AAEA;AACA,oCAAoC,CAAK;AACzC;;AAEA;AACA;AACA;;AAEA,E;;;;;;UCVA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,6CAA6C,wDAAwD,E;;;;;WCArG;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;ACNqC;AACwD;AACY;AAC1B;AACnB;AACE;AACS;AAC3B;AACM;AACP;;;AAGf;;;AAG5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA,iBAAiB,sDAAY;AAC7B,iBAAiB,qDAAW,wBAAwB;AACpD,0DAAc,WAAW;;AAEzB,sEAAkB,QAAQ;;;AAG1B,qBAAqB,+DAAmB;;AAExC,gEAAoB,yBAAyB,yDAAmB;;AAEhE,8DAAiB,GAAG;;AAEpB,2DAAkB,GAAG;;AAErB,iEAAmB;;;;;;;AAOnB;AACA;AACA,IAAI;;;;AAIJ;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;;;;;;;AAOA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,CAAC;AACD;;AAEA;;;;AAIA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;;AAEA;AACA,iCAAiC,yDAAiB,EAAE,uEAAuB;AAC3E,uBAAuB,oDAAY;AACnC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,GAAG;;AAEH;;;AAGA;AACA;AACA;AACA,cAAc,iDAAQ;AACtB;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA,QAAQ,oDAAU;AAClB;;AAEA;AACA;AACA,CAAC","file":"main.js","sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","import {generateMatrixLane} from './matrix.js';\n\nconst inputAdd = document.getElementById('.#sample');\n\nconst FILE_TYPES = ['mp3', 'wav'];\n\nconst uploadFile = (evt, cb) => {\n\n    const sound = evt.files;\n    const fileName = sound.url.toLowerCase();\n  \n    const matches = FILE_TYPES.some((it) => {\n      return fileName.endsWith(it);\n    });\n  \n    if (matches) {\n      const reader = new FileReader();\n      reader.addEventListener('load', cb)\n      reader.readAsDataURL(sound);\n    }\n  };\n  \nconst uploadSound = () => {\n  uploadFile(inputAdd, generateMatrixLane)\n}\n\nconst addInpytAddHandler = () => {\n  inputAdd.addEventListener('click', uploadSound)\n};\n\nexport {addInpytAddHandler}","const bpmControl = document.querySelector('#bpm');\n\n\nconst addBpmInputHandler = () => {\n    bpmControl.addEventListener('change', function() {\n     bpmControl.value = this.value;\n  });\n};\n\nconst setBpm = () => {\n  const bpm = bpmControl.value;\n  return bpm\n}\n\nconst setTempo = () => {\n    const bpm = bpmControl.value\n    const tic = (60 / bpm) / 4;\n    return tic; \n  }\n\nexport {addBpmInputHandler, setBpm, setTempo};\n","\nconst initialCells = (steps) => {\n    let cells = [];\n   \n    for (let i = 0; i < steps; i++) {\n\n      const cell = {\n        played: false,\n        checked: false,\n        disabled: false\n      };\n\n      cells.push(cell);\n    }\n    \n    return cells;\n}\n\nconst createLanes = (sounds, cells) => {\n  const lines = []\n \n  sounds.map((sound) => {\n    const steps = [];\n\n    for (let i = 0; i < cells.length; i++) {\n      const clonedCell = Object.assign({}, cells[i]);\n      steps.push(clonedCell)\n    }\n    const obj = {sound: sound, cells: steps, volume: 1, panner: 0}\n    lines.push(obj)\n  })\n  return lines\n}\n\nconst setCellCheckedColor = (cell) => {\n  const {checked} = cell;\n  switch(checked) {\n    case true:\n      return '#000000';\n    break;\n    case false:\n      return '#ffffff';\n    break;\n    default:\n      return '#ffffff';\n  }\n}\n\nconst setCellPlayedColor = (cell) => {\n  const {played} = cell;\n  switch(played) {\n    case true:\n      return \"#ff00ff\";\n    break;\n    case (!true): \n      return \"\"\n    case false:\n      return \"#ffffff\";\n    break;\n    default:\n      return \"#ffffff\";\n  }\n}\n\n\n\nexport {initialCells, createLanes, setCellCheckedColor, setCellPlayedColor}","\nconst addVolumeControlsHandler = (lanes) => {\n  const volumeControls = document.querySelectorAll('[data-action=\"volume\"]');\n\n  volumeControls.forEach((volumeControl) => {\n        \n        volumeControl.addEventListener('input', (evt) => {\n          volumeControl = evt.target;\n          const i = [...volumeControls].indexOf(volumeControl, 0);\n          const lane = lanes[i]; \n          lane.volume = evt.target.value;\n    })\n  })\n}\n\n\nconst addPannerControlsHandler = (lanes) => {\n  const pannerControls = document.querySelectorAll('[data-action=\"panner\"]');\n  \n    pannerControls.forEach((pannerControl) => {\n\n      pannerControl.addEventListener('input', (evt) => {\n        pannerControl = evt.target;\n        const i = [...pannerControls].indexOf(pannerControl, 0);\n        const lane = lanes[i]; \n        lane.panner = evt.target.value;\n        console.log(lanes);\n      });\n    });\n}\n\nconst addControlsHandlers = (lanes) => {\n  addVolumeControlsHandler(lanes);\n  addPannerControlsHandler(lanes)\n}\n\n\nexport {addControlsHandlers}; ","import {setCellPlayedColor} from './cell.js';\n\nconst sequencer = document.querySelector('.sequencer__wrapper');\nconst sampleList = sequencer.querySelector('.sequencer__samples-list');\nconst sampleTemplate = document.querySelector('#matrix').content.querySelector('.sequencer__samples-item');\n\n// const createLine = (sound) => {\n//   const newSample = sampleTemplate.cloneNode(true);\n//   newSample.querySelector('.button').textContent = sound;\n//   sampleList.append(newSample);\n// }\n\nconst renderStep = () => {\n  const cellElement = document.createElement('button');\n  cellElement.classList.add('sequencer__cell');\n  cellElement.type = 'button';\n  cellElement.tabIndex = 0;\n\n  return cellElement;\n}\n\nconst fillStep = (stepsList, steps) => {\n   \n   const fragment = document.createDocumentFragment();\n   const fragmentOne = document.createDocumentFragment();\n\n   steps.slice(0, 16).forEach((step) => {\n    \n    const newStep = renderStep();\n  \n    fragment.append(newStep);\n    });\n\n    steps.slice(16, 32).forEach((step) => {\n      const newStep = renderStep();\n      fragmentOne.append(newStep);\n      });\n  \n    stepsList[0].append(fragment);\n    stepsList[1].append(fragmentOne);\n};\n  \n  \nconst generateMatrixLane = (lane) => {\n  const{sound, cells} = lane\n  const newSample = sampleTemplate.cloneNode(true);\n  newSample.querySelector('.button').textContent = sound.replace(/^.*[\\\\\\/]/, '').slice(0, -4);\n  sampleList.append(newSample);\n\n  const stepsList = newSample.querySelectorAll('.sequencer__step-list');\n  fillStep(stepsList, cells); \n};\n\n\nconst generateMatrix = (lanes) => {\n    lanes.forEach((lane) => {\n    generateMatrixLane(lane);\n  })\n};\n\nconst createCellsArray = (i) => {\n  const slidesFirst = document.querySelectorAll('.slide-1');\n  const slidesSecond = document.querySelectorAll('.slide-2');\n  \n  const cellsOfLane = [];\n    cellsOfLane.push.apply(cellsOfLane, slidesFirst[i].children);\n    cellsOfLane.push.apply(cellsOfLane, slidesSecond[i].children);\n    return cellsOfLane;\n}\n\nconst createAllCellsArray = () => {\n  const allCellsLists = []\n  for (let i = 0; i < 3; i++) {\n    const cellsOfLane = createCellsArray(i);\n    allCellsLists.push(cellsOfLane);\n  }\n  return allCellsLists\n}\n\nconst addButtonCellHandler = (cellsElements, lanes, cb) => {\n  //const cellsButtonsArray = createAllCellsArray();\n  cellsElements.forEach((cellsOfLane) => {\n\n    cellsOfLane.forEach((cell) => cell.addEventListener('click', (evt) => {\n      const i = cellsElements.indexOf(cellsOfLane, 0);\n      const {cells} = lanes[i];\n      const cell = evt.target;\n      const j = cellsOfLane.indexOf(cell, 0);\n      cells[j].checked = cells[j].checked ? false : true; \n      cell.style.background = cb(cells[j]);\n    }))\n  })\n};\n\nconst renderPlayedCells = (cellsElements, lanes) => {\n\n  lanes.forEach((lane) => {\n    const {cells} = lane;\n    cells.forEach((cell) => {\n      const i = lanes.indexOf(lane);\n      const cellsOfLane = cellsElements[i];\n      const j = cells.indexOf(cell, 0);\n\n      if (cell.played != false) {\n        cellsOfLane[j].style.borderColor = setCellPlayedColor(cell);\n      }\n      \n    })\n  })\n}\n\n\n//создание новой дорожки\n\n  \n\n// const deleteLane = (lanes) => {\n  \n//   const before = lanes.slice(0, i);\n//   const after = lanes.slice(i, i + 1);\n//     const newArray = [...before, ...after];\n\n//     return {\n//       lanes: newArray,\n//     }\n//   })\n// };\n\n\n\n\n  \n  export {generateMatrix, createAllCellsArray, generateMatrixLane, addButtonCellHandler, renderPlayedCells}","const playbackWrapper = document.querySelector('.sequencer__playback');\n\nconst renderPlaybackLine = () => {\n    const fragment = document.createDocumentFragment();\n\n    for(let i = 0; i < 16; i++) {\n\n   \n    const playbackStep = document.createElement('div');\n\n    playbackStep.classList.add('sequencer__playback-element');\n\n    fragment.append(playbackStep);\n    }\n    playbackWrapper.append(fragment);\n}\n\nconst fillCurrentPlaybackStep = (currentStep) => {\n    const playbackSteps = document.querySelectorAll('.sequencer__playback-element');\n\n    [...playbackSteps].forEach((playbackStep) => {\n        const currentSte = playbackSteps[currentStep - 1];\n        if (playbackStep == currentSte) {\n            playbackStep.classList.add('sequencer__playback-element--played')\n        }    \n        else {\n            playbackStep.classList.remove('sequencer__playback-element--played');\n        }\n\n    })\n}\n\nexport {renderPlaybackLine, fillCurrentPlaybackStep}","const playButton = document.getElementById('play');\nconst stopButton = document.getElementById('stop');\n\nconst playProject = (project) => {\n   const {isPlayed} = project;\n   isPlayed = true; \n   cb()\n\n}\n\nconst stopPlaybackProject = (project) => {\n    const {isPlayed} = false;\n    cb();\n}\n\nconst addButtonPlayHandler = (callback, cb) => {\n    playButton.addEventListener('click', (callback));\n    stopButton.removeEventListener('click', (cb))\n}\n\nconst addButtonStopHandler = (cb, callback) => {\n    stopButton.addEventListener('click', (cb));\n    playButton.removeEventListener('click', callback)\n\n}\n\nexport {addButtonPlayHandler, addButtonStopHandler}","const createProject = (newLanes, bpm) => {\n    const project = {bpm: bpm, lanes: newLanes, isPlayed: false}\n    return project;\n}\n\n\n\n// export default class Project {\n\n//         constructor (bpm, lanes) {\n//           this.bpm = bpm;\n//           this.lanes = lanes;\n//         }\n      \n// }\n\nexport {createProject} ","const nextArrow = document.querySelector('.slider__arrow--next');\nconst previousArrow = document.querySelector('.slider__arrow--prev');\nlet slideNumber = 1;\n\n const showSlide = (n) => {\n  const slidesLists = document.querySelectorAll('.slider-tracker');\n\n  slidesLists.forEach((slidesList) => {\n      const slides = slidesList.children\n\n      let i;\n      if (n > slides.length) {\n        slideNumber = 1;\n      }\n      if (n < 1) {\n        slideNumber = slides.length;\n      }\n      for (i = 0; i < slides.length; i++) {\n        slides[i].classList.remove(\"current-slide\");\n      }\n\n      slides[slideNumber-1].classList.add(\"current-slide\");\n    });\n    }\n\nconst onNextArrowClick = () => {\n  showSlide(slideNumber += 1);\n}\n\nconst onPreviousArrowClick = () => {\n  showSlide(slideNumber -= 1);\n}\nfunction currentSlide (n) {\n  showSlide(slideNumber = n);\n}\n\n\nconst addArrowsHandlers = () => {\n  nextArrow.addEventListener('click', onNextArrowClick);\n  previousArrow.addEventListener('click', onPreviousArrowClick);\n}\n\nexport {addArrowsHandlers, currentSlide}\n\n","const PRIMARY_MOUSE_BUTTON = 0;\n\nconst isEscEvent = (evt) => {\n    return evt.key === ('Escape' || 'Esc');\n  };\n  \n  const isMouseLeftEvent = (evt) => {\n    return evt.button === PRIMARY_MOUSE_BUTTON;\n  }\n  \n  export {isEscEvent, isMouseLeftEvent}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {isEscEvent} from './util.js';\nimport {initialCells, setCellCheckedColor, createLanes, setCellPlayedColor} from './cell.js';\nimport {addButtonCellHandler, generateMatrix, createAllCellsArray, renderPlayedCells} from './matrix.js';\nimport {renderPlaybackLine, fillCurrentPlaybackStep} from './playback-cells.js'\nimport {addArrowsHandlers, currentSlide} from './slider.js';\nimport {addBpmInputHandler, setBpm, setTempo} from './bpm.js';\nimport {addButtonPlayHandler, addButtonStopHandler} from './player.js';\nimport {addInpytAddHandler} from './add.js';\nimport {addControlsHandlers} from './controls.js';\nimport {createProject} from './project.js';\n\n\nimport '../sass/style.sass';\n\n\nlet sounds = ['./samples/bdsh.wav',\n                './samples/boom.wav',\n                './samples/tsk.wav',\n              ];\n\nconst STEPS = 32;\nconst activeStep = 30;\n\nlet context = new (window.AudioContext || window.webkitAudioContext)();\n\nclass Buffer {\n\n  constructor(context, urls) {\n    this.context = context;\n    this.urls = urls;\n    this.buffer = [];\n  }\n\n  loadSound(url, index) {\n    let request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    let thisBuffer = this;\n    request.onload = function() {\n\n      thisBuffer.context.decodeAudioData(request.response, function(data) {\n          thisBuffer.buffer[index] = data;\n      });\n\n     };\n    request.send();\n  };\n\n  createBuffer() {\n    this.urls.forEach((url, index) => {\n      this.loadSound(url, index);\n\n    })\n  }\n\n getSound(index) {\n    return this.buffer[index];\n  }\n\n}\n\nconst buffer = new Buffer(context, sounds)\nbuffer.createBuffer();\n\n/////////////////////////\n\n\nconst newCells = initialCells(STEPS);\nconst newLanes = createLanes(buffer.urls, newCells); //дорожки\ngenerateMatrix(newLanes); // отрисовка дорожек\n\nrenderPlaybackLine(STEPS);// \n\n\nconst cellsButtons = createAllCellsArray();\n\naddButtonCellHandler(cellsButtons, newLanes, setCellCheckedColor)\n\naddArrowsHandlers(); //стрелки слайдера\n\naddBpmInputHandler(); //bpm\n\naddControlsHandlers(newLanes) //звук и панорама для дорожек\n\n\n\n\n\n\n// addFilterHandlers(\n//   debounce(renderOffersPin, DEBOUNCE_TIME));\n// })\n\n\n\n////Bufer////////////////////////////////////////////////////////\n\n\n\n\n\n\nconst playSound = (audioData, playTime, volume, pans) => {\n  const source = context.createBufferSource();\n  source.buffer = audioData;\n\n  const gainNode= context.createGain();\n  gainNode.gain.value = volume;\n\n  const pannerOptions = {pan: 0};\n  const panner = new StereoPannerNode(context, pannerOptions);\n  panner.pan.value = pans;\n\n  source.connect(gainNode).connect(panner).connect(context.destination);\n\n    source.start(playTime);\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////\n\n\n\n\nconst onButtonPlaySound = () => {\n\nlet button = document.getElementsByClassName('button');\nvar allSounds = [];\n  allSounds.push.apply(allSounds, button);\n\n\n  allSounds.forEach((btn) => btn.addEventListener('click', (evt) => {\n      btn = evt.target;\n      const i = allSounds.indexOf(btn, 0);\n\n    playSound(buffer.getSound(i), 0, 1, 0)\n\n}))\n}\n\nonButtonPlaySound();\n\n\n\n//Sequencer\n\n\nlet startTime = 0;\nlet nextStepTime = 0.0;\nlet currentStep = 0;\n\n\nfunction scheduleSound() {\n  let now = context.currentTime;\n  now -= startTime;\n \n\n  while (nextStepTime < now + 0.2 ) {\n\n    let pt = nextStepTime + startTime;\n    playStepAtTime(newLanes, pt, renderPlayedCells, fillCurrentPlaybackStep);\n    nextStep(newLanes, currentSlide);\n  }\n    const ti = setTimeout(scheduleSound, 0)\n    \n}\n\nfunction nextStep(lanes, callback) {\n  currentStep++;\n\n  lanes.forEach((lane) => {\n\n    const {cells} = lane;\n    cells.forEach((cell) => {\n      const currentCell = lane.cells[currentStep - 1];\n\n      if (cell = currentCell) {\n        cell.played = true;\n      }\n      else {\n        cell.played = false // не работает\n      };\n\n    });\n  });\n\n  currentStep > 16 ? callback(2)  : callback(1);\n\n\n  if (currentStep === activeStep) {\n    currentStep = 0;\n  }\n  let tempo = setTempo();\n  nextStepTime += tempo;\n}\n\nfunction playStepAtTime(lanes, playTime, callback, cb) {\n\n    for(let i = 0; i < lanes.length; i++) {\n        const lane = lanes[i];\n        const volume = lane.volume;\n        const panner = lane.panner;\n        if (lane.cells[currentStep].checked != false) {\n          playSound(buffer.getSound(i), playTime, volume, panner);\n        }\n    }\n    callback(cellsButtons, newLanes);\n    cb(currentStep)\n    \n}\n\n// let bpm = setBpm();\n//     let project = createProject(newLanes, bpm);\n//     console.log(project)\n\n\nfunction play() {\n  \n  //nextStepTime = 0;\n  //startTime = context.currentTime + 0.005;\n  scheduleSound();\n\n}\n\n\n\n\n// function stop() {\n//   isPlaying = false;\n//   scheduleSound()\n//   console.log('stop')\n//   console.log(isPlaying)\n// }\n\n\n\n// addButtonPlayHandler(play, stop);\n// addButtonStopHandler(stop, play)\n\n\n\n\n\n// const loop = () => {\n//   let spb = (60/120);\n//   let frames = 0;\n\n//    let currentC = 0;\n//    let lastStep = -1;\n\n//   if(!isPlaying) {\n//     frames++;\n\n//     let seconds = 60/frames;\n//     let beatTime = spb/seconds%activeStep;\n\n\n//     lastStep = currentC;\n//     currentC = Math.floor(beatTime*4);\n\n\n//     if(lastStep != currentC) {\n\n\n//      //for (let i = 0; i < activeStep; i++) {\n//       if(lastStep === i) {\n//         now = 0;\n//         playSound(buffer.getSound(1))\n//         playSound(buffer.getSound(2))\n//       }\n//     }\n//   }\n\n// }\n//   requestAnimationFrame(loop)\n\n// }\n\n\n\ndocument.addEventListener('keydown', (evt) => {\n\n    if (isEscEvent(evt)) {\n      evt.preventDefault();\n    \n      play()\n    }\n});\n"],"sourceRoot":""}